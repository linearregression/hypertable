#A brief introduction to Hypertable Query Language (HQL)

==CONTENTS==

  * SETUP
  * INTERACTIVE HYPERTABLE AND HQL
  * CREATE TABLE
  * LOAD DATA INFILE
  * SELECT
  * INSERT & DELETE
  * BATCH MODE AND SOURCE

===SETUP===

In this example we'll startup a local hypertable instance, create a table, load some access log data from a file, and do some basic operations using interactive Hypertext Query Language (HQL) commands. Afterwards, we'll demonstrate use of the --batch mode for HQL.

Hypertable is designed to be "always on" but for the purposes of this example we'll assume you're running locally from a fresh install. Also, following the `README.txt` in the distribution we assume your hypertable directory is `~/hypertable`

{{{
codeslinger:~> cd ~/hypertable
codeslinger:~/hypertable> bin/start-all-servers.sh local

codeslinger:~/hypertable>  bin/start-all-servers.sh local
Successfully started DFSBroker (local)
Successfully started Hyperspace
Successfully started Hypertable.Master
Successfully started Hypertable.RangeServer
}}}

Now, fire up an interactive session:

{{{
codeslinger:~/hypertable> bin/hypertable
Welcome to the HQL command interpreter.

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

hypertable>
}}}

Start with a simple 'help':

{{{
hypertable> help

For information about Hypertable, visit http://www.hypertable.org/

Interpreter Commands
--------------------
?          (\?) Synonym for `help'.
clear      (\c) Clear command.
exit       (\q) Exit hypertable. Same as quit.
print      (\p) Print current command.
quit       (\q) Quit hypertable.
source <f> (.)  Execute all HQL commands in file <f>.
system     (\!) Execute a system shell command.

HQL Statements
--------------
CREATE TABLE ....... Creates a table
DELETE ............. Delete all or part of a row from a table
DESCRIBE TABLE ..... Displays a table's schema
INSERT ............. Inserts data into a table
LOAD DATA INFILE ... Loads data from a tab delimited input file into a table
SELECT ............. Select (and display) cells from a table
SHOW CREATE TABLE .. Displays CREATE TABLE command used to create table

Statements must be terminated with ';' to execute.  For more information on
a specific statement, type 'help <statement>', where <statement> is one from
the preceeding list.
}}}

===INTERACTIVE HYPERTABLE AND HQL===

For this example we're working with a simplified access log that contains four columns: the url for a page access on one of our hosts, a `timestamp` field in the required format (e.g. _'YYYY-MM-DD hh:mm:ss'_), the referrer's url, and an http code. There are 100,000 records in the file.

The file is under `examples/hql_tutorial/access.tsv` and you'll need to unzip it first if it's still compressed. _NOTE: `LOAD DATA INFILE` will a compressed file option soon._

==CREATE TABLE==

First, we need to create a table to hold the data from our simplified access log -- we'll call it `Pages`:

{{{
hypertable> create table Pages ( date, "refer-url", "http-code");
}}}

Column names that contain a dash or any non-alphanumeric character (e.g. "refer-url") must be enclosed in quotes. Now, issue the `SHOW CREATE TABLE` command to make sure you got everything right.

{{{
hypertable> show create table Pages;

CREATE TABLE Pages (
  'refer-url',
  'http-code',
  date,
  ACCESS GROUP default ( 'refer-url', 'http-code' )
)

}}}

And, notice that, by default, a single `ACCESS GROUP` is created -- see the full documentation for details on that but basically the `ACCESS GROUP` is an optimization.

Further, we get a minimal schema description via:

{{{
hypertable> describe table Pages;
<Schema generation="1">
  <AccessGroup name="default">
    <ColumnFamily id="1">
      <Name>refer-url</Name>
    </ColumnFamily>
    <ColumnFamily id="2">
      <Name>http-code</Name>
    </ColumnFamily>
    <ColumnFamily id="3">
      <Name>date</Name>
    </ColumnFamily>
  </AccessGroup>
</Schema>

}}}

===LOAD DATA INFILE===

Now, let's load some data using the MySQL-like TAB delimited format (TSV). For that, we assume you have the example data in `examples/hql_tutorial/access.tsv`. This format includes a single header line that gives `column_family_names` (no `column_qualifiers` supported for this format yet). For the example, our data file has header:

{{{
# rowkey        date    refer-url       http-code
events.mercurynews.com/venues   2008-01-25 15:19:32     events.mercurynews.com/search   200
www.zvents.com/events/auto_complete_for_artist_name     2008-01-25 15:19:32     www.zvents.com/indio-ca/events/show/81296496-coachella  200
calendar.denverpost.com/search  2008-01-25 15:19:32     calendar.denverpost.com/search  200
www.zvents.com/search   2008-01-25 15:19:32     www.zvents.com/search   200

}}}

_Reminder: you'll need to unzip it first if it's still compressed._

====LOAD DATA INFILE (INTO TABLE)====

So, now we load it into our Pages table:

{{{
hypertable> load data infile ROW_KEY_COLUMN=rowkey "examples/hql_tutorial/access.tsv" into table Pages;

Loading  10,872,957 bytes of input data...

0%   10   20   30   40   50   60   70   80   90   100%
|----|----|----|----|----|----|----|----|----|----|
***************************************************
Load complete.

  Elapsed time:  6.00 s
Avg value size:  18.68 bytes
  Avg key size:  48.70 bytes
    Throughput:  1811875.04 bytes/s
 Total inserts:  300000
    Throughput:  49992.15 inserts/s
       Resends:  0

}}}

====LOAD DATA INFILE (INTO FILE)====

Also, make sure you don't skip over an important utility for converting these more standard formatted files into insert files used by hypertable client programs:

{{{
hypertable> load data infile ROW_KEY_COLUMN=rowkey "examples/hql_tutorial/access.tsv" into file "test.tsv";

Loading  10,872,957 bytes of input data...

0%   10   20   30   40   50   60   70   80   90   100%
|----|----|----|----|----|----|----|----|----|----|
***************************************************
Load complete.

  Elapsed time:  2.41 s
Avg value size:  18.68 bytes
  Avg key size:  48.70 bytes
    Throughput:  4513692.45 bytes/s
 Total inserts:  300000
    Throughput:  124539.05 inserts/s
}}}

And, now we have a new file, `test.tsv`, with the fully specified hypertable insert format which illustrates the fundamental key/value sparse representation of our data (which would be more clear if we were using `column_qualifiers`)

{{{
codeslinger:~/hypertable>  head -10 test.tsv 
rowkey  columnkey       value
events.mercurynews.com/venues   date    2008-01-25 15:19:32
events.mercurynews.com/venues   refer-url       events.mercurynews.com/search
events.mercurynews.com/venues   http-code       200
www.zvents.com/events/auto_complete_for_artist_name     date    2008-01-25 15:19:32
www.zvents.com/events/auto_complete_for_artist_name     refer-url       www.zvents.com/indio-ca/events/show/81296496-coachella
www.zvents.com/events/auto_complete_for_artist_name     http-code       200
calendar.denverpost.com/search  date    2008-01-25 15:19:32
calendar.denverpost.com/search  refer-url       calendar.denverpost.com/search
calendar.denverpost.com/search  http-code       200
}}}

===SELECT===

Now, let's use the `SELECT` command to examine our data a bit -- let's start by looking at all the accesses for a particular page (a Steve Martin event in san francisco) and check the referrer's url:

{{{
hypertable> select "refer-url" from Pages where ROW = "www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin";
2008-01-25 11:26:13.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.google.com/search
2008-01-25 11:25:50.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.google.com/search
2008-01-25 10:02:43.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.zvents.com/search
2008-01-25 08:29:31.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.google.com/search
2008-01-25 08:20:04.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.google.com/search
2008-01-25 08:12:29.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       refer-url       www.google.com/search
}}}

or the http code we returned:

{{{
hypertable> select "http-code" from Pages where ROW = "www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin";
2008-01-25 11:26:13.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 11:25:50.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 10:02:43.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 08:29:31.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 08:20:04.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 08:12:29.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
}}}

Looks good! Okay, let's restrict the time by adding to the `WHERE` clause:

{{{
hypertable> select "http-code" from Pages where ROW = "www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin" && TIMESTAMP > '2008-01-25 09:00:00';
2008-01-25 11:26:13.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 11:25:50.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
2008-01-25 10:02:43.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
}}}

Or, restrict to just one hour:

{{{
hypertable> select "http-code" from Pages where ROW = "www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin" && TIMESTAMP > '2008-01-25 10:00:00' && TIMESTAMP < '2008-01-25 11:00:00';
2008-01-25 10:02:43.000000000   www.zvents.com/san-francisco-ca/events/show/80283482-steve-martin       http-code       200
}}}

Of course, we can choose a range of row keys as well:

{{{
hypertable> select "http-code" from Pages where ROW >= "www.zvents.com/events/buy_tickets/80283482" && ROW <= "www.zvents.com/events/buy_tickets/80300000";
2008-01-25 11:26:17.000000000   www.zvents.com/events/buy_tickets/80283482      http-code       200
2008-01-25 11:26:02.000000000   www.zvents.com/events/buy_tickets/80283482      http-code       200
2008-01-25 08:20:17.000000000   www.zvents.com/events/buy_tickets/80283482      http-code       200
}}}

And, again looking for activity in a particular hour:

{{{
hypertable> select "http-code" from Pages where ROW >= "www.zvents.com/events/buy_tickets/80283482" && ROW <= "www.zvents.com/events/buy_tickets/80300000" && TIMESTAMP > '2008-01-25 11:00:00' && TIMESTAMP < '2008-01-25 12:00:00';
2008-01-25 11:26:17.000000000   www.zvents.com/events/buy_tickets/80283482      http-code       200
2008-01-25 11:26:02.000000000   www.zvents.com/events/buy_tickets/80283482      http-code       200
}}}

===INSERT & DELETE===

Though it's unlikely to be needed in interactive mode let's do a quick demonstration of `INSERT`. The key to remember is that hypertable data is versioned by time stamp and that you can either set the time stamp on insert or accept the default based on your current system time. Delete operations also have a time stamp and the delete operates on all data occurring at the time stamp or *_before_*.

For example, let's `INSERT` some data in the past and issue a select command to verify the data:

{{{
hypertable> insert into Pages values ('2006-01-01 23:59:59', "www.hypertable.org", "refer-url", "www.zvents.com");
hypertable> select * from Pages where ROW = "www.hypertable.org";
2006-01-01 23:59:59.000000000   www.hypertable.org      refer-url       www.zvents.com
}}}

Now, let's do a `DELETE` with the default time stamp and verify that's it deleted using a `SELECT`:

{{{
hypertable> delete * from Pages where ROW = "www.hypertable.org";
delete: row='www.hypertable.org' family=0 ts=0
hypertable> select * from Pages where ROW = "www.hypertable.org";
}}}

Now, we'll `INSERT` some data far into the future (as of this tutorial) and verify that it survives the `DELETE`:

{{{
hypertable> insert into Pages values ('2037-01-01 23:59:59', "www.hypertable.org", "refer-url", "www.zvents.com");
hypertable> delete * from Pages where ROW = "www.hypertable.org";
delete: row='www.hypertable.org' family=0 ts=0
hypertable> select * from Pages where ROW = "www.hypertable.org";
2037-01-01 23:59:59.000000000   www.hypertable.org      refer-url       www.zvents.com
}}}

Now, let's get rid of it with `DELETE` time stamped further into the future:

{{{
hypertable> delete * from Pages where ROW = "www.hypertable.org" TIMESTAMP '2038-01-01 23:59:59';
delete: row='www.hypertable.org' family=0 ts=2146031999000000001
hypertable> select * from Pages where ROW = "www.hypertable.org";
}}}


===BATCH MODE AND SOURCE===

After killing the servers via `kill-servers.sh` your tables and data are no longer available (recovery is coming soon).  In order to recover your tables and other data you can run the system in batch mode or use `SOURCE` from an interactive console.


You can fire up an interactive session and use the `source` command:

{{{
hypertable> source examples/hql_tutorial/Pages-create.hql 

Loading  10,872,962 bytes of input data...

0%   10   20   30   40   50   60   70   80   90   100%
|----|----|----|----|----|----|----|----|----|----|
***************************************************
Load complete.

  Elapsed time:  5.71 s
Avg value size:  18.51 bytes
  Avg key size:  48.70 bytes
    Throughput:  1905283.61 bytes/s
 Total inserts:  200000
    Throughput:  35046.27 inserts/s
       Resends:  0

}}}

Alternatively, to avoid opening up an interactive session you can use the --batch command:

{{{
codeslinger:~/hypertable>  bin/hypertable --batch < examples/hql_tutorial/Pages-create.hql 
CREATE TABLE Pages (
"refer-url",
"http-code",
ACCESS GROUP default ( "refer-url", "http-code" )
);
load data infile ROW_KEY_COLUMN=rowkey TIMESTAMP_COLUMN=timestamp "examples/hql_tutorial/access.tsv" into table Pages;

Loading  10,872,962 bytes of input data...

0%   10   20   30   40   50   60   70   80   90   100%
|----|----|----|----|----|----|----|----|----|----|
***************************************************
Load complete.

  Elapsed time:  5.42 s
Avg value size:  18.51 bytes
  Avg key size:  48.70 bytes
    Throughput:  2005246.89 bytes/s
 Total inserts:  200000
    Throughput:  36885.02 inserts/s
       Resends:  0

}}}

You can examine the file in `examples/hql_tutorial/Pages-create.hql` to verify that it's just a batch of HQL commands.