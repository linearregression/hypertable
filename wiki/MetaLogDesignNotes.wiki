#summary Design/API notes for MetaLog classes

= Introduction =

To support [RangeMetaOperationTransactions transactions of range metadata operations], we need a family of meta log classes.

The basic format for the log is:
{{{
log ::= <log_entry> | <log> <log_entry>
log_entry ::= <checksum> <log_type> <payload_size> <payload>
checksum :: = <fletcher32 of <log_type> <payload_size> <payload>>
log_type ::= <8-bit unsigned integer with value of MetaLogEntry::Type below>
payload_size ::= <an unsigned 32 bit integer>
payload ::= <blob serialized depending on <log_type>>
}}}
= API =
{{{
class MetaLogEntry : public ReferenceCount {
public:

  virtual ~MetaLogEntry() = 0;

  virtual void write(DynamicBuffer &) = 0;
  virtual void read(const void *buf, size_t len) = 0;
  virtual void is_valid() = 0;

  virtual int get_type() = 0; 
};
typedef boost::instrusive_ptr<MetaLogEntry> MetaLogEntryPtr;
}}}
{{{
enum MetaLogEntryType {
  UNKNOWN = -1,
  RS_SPLIT_START,
  RS_SPLIT_SHRUNK,
  RS_SPLIT_DONE,
  RS_RANGE_LOADED,
  RS_MOVE_START,
  RS_MOVE_PREPARED,
  RS_MOVE_DONE,
  M_LOAD_RANGE_START,
  M_LOAD_RANGE_FINISH,
  M_MOVE_RANGE_START,
  M_MOVE_RANGE_FINISH,
  M_RECOVERY_START,
  M_RECOVERY_COMPLETE
};
}}}
{{{
namespace MetaLogEntryFactory {
  
MetaLogEntry *new_rs_split_start(const Range &old, const std::string &split_log);
MetaLogEntry *new_rs_split_shrunk(const Range &old, const Range &new);
MetaLogEntry *new_rs_split_done(const Range &old);
MetaLogEntry *new_rs_range_loaded(const Range &);
MetaLogEntry *new_rs_move_start(const Range &, const std::string &move_log);
MetaLogEntry *new_rs_move_prepared(const Range &);
MetaLogEntry *new_rs_move_done(const Range &);
MetaLogEntry *new_m_load_range_start(const Range &, const std::string &rs_to, const std::string& split_log);
MetaLogEntry *new_m_load_range_finish(const Range &);
MetaLogEntry *new_m_move_range_start(const Range &, const std::string &rs_from, const std::string &rs_to);
MetaLogEntry *new_m_move_range_finish(const Range &);
MetaLogEntry *new_m_recovery_start(const std::string &rs_from);
MetaLogEntry *new_m_recovery_finish(const std::string &rs_from);

MetaLogEntry *new_from_payload(MetaLogEntryType, const void *buf, size_t len);

} // namespace MetaLogEntryFactory
}}}
{{{
class MetaLog {
public:
  virtual ~MetaLog() = 0;
  
  virtual void write(MetaLogEntry *) = 0;
  virtual void close() = 0;

  // Remove finished entries except rs_range_loaded
  virtual void compact() = 0;
};
}}}
{{{
class MetaLogReader {
public:
  struct ScanEntry {
    MetaLogEntryType type;
    uint32_t checksum;
    size_t payload_size;
    const void *payload;
  };

public:
  virtual ~MetaLogReader() = 0;
  
  // quick scan without deserialize entries, throws if invalid
  virtual ScanEntry *next(ScanEntry *) = 0;
  virtual ScanEntry *last(ScanEntry *) = 0;

  // read and get ready for the next record, throws if invalid
  virtual MetaLogEntry *read() = 0;
  virtual MetaLogEntry *read_last() = 0;
};
}}}

= Implementation Notes =

There is a class for each type of entry to handle its special arguments and serialization.
  

  