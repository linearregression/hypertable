#summary Design/API notes for MetaLog classes

= Introduction =

To support [RangeMetaOperationTransactions transactions of range metadata operations], we need a family of meta log classes.

The basic format for the log is:
{{{
log ::= <log_entry> | <log> <log_entry>
log_entry ::= <checksum> <log_type> <payload_size> <payload>
checksum :: = <fletcher32 of <log_type> <payload_size> <payload>>
log_type ::= <8-bit unsigned integer with value of MetaLogEntry::Type below>
payload_size ::= <an unsigned 32 bit integer>
payload ::= <blob serialized depending on <log_type>>
}}}
= API =
{{{
class MetaLogEntry : public ReferenceCount {
public:
  enum Type {
    UNKNOWN = -1,
    RS_SPLIT_START,
    RS_SPLIT_SHRUNK,
    RS_SPLIT_DONE,
    RS_RANGE_LOADED,
    M_LOAD_RANGE_START,
    M_LOAD_RANGE_FINISH,
    M_RECOVERY_START,
    M_RECOVERY_COMPLETE
  };

  virtual ~MetaLogEntry() = 0;

  // common interface
  virtual void write(DynamicBuffer &) = 0;
  virtual void read(const void *buf, size_t len) = 0;
  virtual void is_valid() = 0;
  
  // reflection helpers
  virtual Type get_type() = 0;

  // faster than dynamic_cast and doesn't throw.
  template <class LogEntryT>
  LogEntryT *cast() { 
    if (LogEntryT::type == get_type())
      return (LogEntryT *)this;
    else 
      return NULL;
  }
};
typedef boost::instrusive_ptr<MetaLogEntry> MetaLogEntryPtr;
}}}
{{{
namespace MetaLogEntryFactory {

MetaLogEntry *new_rs_split_start(const Range &old, const std::string &split_log);
MetaLogEntry *new_rs_split_shrunk(const Range &old, const Range &new);
MetaLogEntry *new_rs_split_done(const Range &old);
MetaLogEntry *new_rs_range_loaded(const Range &);
MetaLogEntry *new_m_load_range_start(const Range &, const std::string& split_log);
MetaLogEntry *new_m_load_range_finish(const Range &);
MetaLogEntry *new_m_recovery_start();
MetaLogEntry *new_m_recovery_finish();

MetaLogEntry *new_from_payload(MetaLogEntry::Type, const void *buf, size_t len);

}
}}}
{{{
class MetaLog {
public:
  virtual ~MetaLog() = 0;
  
  virtual void write(MetaLogEntry *) = 0;
  virtual void close() = 0;

  // Remove finished entries except rs_range_loaded
  virtual void compact() = 0;
};
}}}
{{{
class MetaLogReader {
public:
  struct ScanEntry {
    MetaLogEntry::Type type;
    uint32_t checksum;
    size_t payload_size;
    const void *payload;
  };

public:
  virtual ~MetaLogReader() = 0;
  
  // quick scan without deserialize entries, throws if invalid
  virtual void next(ScanEntry *) = 0;
  virtual void last(ScanEntry *) = 0;

  // read and get ready for the next record, throws if invalid
  virtual MetaLogEntryPtr read() = 0;
  virtual MetaLogEntryPtr read_last() = 0;
};
}}}

= Implementation Notes =

There is a class for each type of entry to handle its special arguments and serialization.
  

  