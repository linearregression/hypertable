#summary Design/API notes for MetaLog classes

= Introduction =

To support [RangeMetaOperationTransactions transactions of range metadata operations], we need a family of meta log classes.

The basic format for the log is:
{{{
log ::= <log_entry> | <log> <log_entry>
log_entry ::= <checksum> <log_type> <payload_size> <payload>
checksum :: = <fletcher32 of <log_type> <payload_size> <payload>>
log_type ::= <8-bit unsigned integer with value of MetaLogEntry::Type below>
payload_size ::= <an unsigned 32 bit integer>
payload ::= <blob serialized depending on <log_type>>
}}}
= API =
{{{
class MetaLogEntry {
public:
  virtual ~MetaLogEntry() {}

  virtual void write(DynamicBuffer &) = 0;
  virtual void read(const void *buf, size_t len) = 0;
  virtual void is_valid() = 0;

  virtual int get_type() = 0; 
};
}}}
{{{
enum MetaLogEntryType {
  UNKNOWN = -1,
  RS_SPLIT_START,
  RS_SPLIT_SHRUNK,
  RS_SPLIT_DONE,
  RS_RANGE_LOADED,
  RS_MOVE_START,
  RS_MOVE_PREPARED,
  RS_MOVE_DONE,
  M_LOAD_RANGE_START,
  M_LOAD_RANGE_DONE,
  M_MOVE_RANGE_START,
  M_MOVE_RANGE_DONE,
  M_RECOVERY_START,
  M_RECOVERY_DONE
};
}}}
{{{
namespace MetaLogEntryFactory {
  
MetaLogEntry *new_rs_split_start(const Range &old, const Range &split_off, const String &transfer_log);
MetaLogEntry *new_rs_split_shrunk(const Range &old);
MetaLogEntry *new_rs_split_done(const Range &old);
MetaLogEntry *new_rs_range_loaded(const Range &);
MetaLogEntry *new_rs_move_start(const Range &, const String &transfer_log);
MetaLogEntry *new_rs_move_prepared(const Range &);
MetaLogEntry *new_rs_move_done(const Range &);
MetaLogEntry *new_m_load_range_start(const Range &, const String &rs_to, const String &transfer_log);
MetaLogEntry *new_m_load_range_done(const Range &);
MetaLogEntry *new_m_move_range_start(const Range &, const String &rs_from, const String &rs_to);
MetaLogEntry *new_m_move_range_done(const Range &);
MetaLogEntry *new_m_recovery_start(const String &rs_from);
MetaLogEntry *new_m_recovery_done(const String &rs_from);

MetaLogEntry *new_from_payload(MetaLogEntryType, const void *buf, size_t len);

} // namespace MetaLogEntryFactory
}}}
{{{
class MetaLog {
public:
  virtual ~MetaLog() {}
  
  virtual void write(MetaLogEntry *) = 0;
  virtual void close() = 0;

  // Remove finished entries except rs_range_loaded
  virtual void compact() = 0;
};
}}}
{{{
class MetaLogReader {
public:
  struct ScanEntry {
    MetaLogEntryType type;
    uint32_t checksum;
    size_t payload_size;
    const void *payload;
  };

public:
  virtual ~MetaLogReader() {}
  
  // quick scan without deserialize entries, throws if invalid
  virtual ScanEntry *next(ScanEntry *) = 0;
  virtual ScanEntry *last(ScanEntry *) = 0;

  // read and get ready for the next record, throws if invalid
  virtual MetaLogEntry *read() {
    ScanEntry se;

    if (!next(&se))
      return NULL;

    return MetaLogEntryFactory::new_from_payload(se.type, se.payload, se.payload_size);
  }

  virtual MetaLogEntry *read_last() {
    ScanEntry se;

    if (!last(&se))
      return NULL;

    return MetaLogEntryFactory::new_from_payload(se.type, se.payload, se.payload_size);
  }
};
}}}

= Implementation Notes =

There is a class for each type of entry to handle its special arguments and serialization.
  

  