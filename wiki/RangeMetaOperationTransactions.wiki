#summary Design of range meta-operation transactions
#labels Phase-Design

== Introduction ==

Ranges are assigned and re-assigned to !RangeServers by the following operations:

  * CREATE TABLE
  * Range split
  * Range migration

To ensure that each Range get assigned to a !RangeServer and that a Range doesn't accidentally get assigned to multiple !RangeServers, even in the face of failures, we've decided to implement a specialized form of range meta-operation transactions.  This document describes the design of this mechanism.

To support these range meta-operation "transactions", we've introduced two new commit logs:

  # RSML - !RangeServer Meta Log
  # MML - Master Meta Log

These logs are where all Range meta operations get recorded for the !RangeServers and Master, respectively.

-----

== Load Range ==

=== Master ===

  # Writes M_LOAD_RANGE_START (with location of receiving !RangeServer) entry to MML
  # Calls load_range(<split-log>) on receiving !RangeServer
  # Update METADATA 'Location' column for the new range
  # Write M_LOAD_RANGE_DONE entry to MML

=== !RangeServer ===

  # Append RS_RANGE_LOADED in RSML
  # Create Range directory in DFS
  # Link transfer log into primary log
  # Replay transfer log
  # Add Range object to main map
  # Respond OK to Master

-----

== Range Split ==

=== Originating !RangeServer ===

  # Decide to split range
  # Create a transfer log and append RS_SPLIT_START entry to RSML (include transfer log location)
  # Do major compaction
  # Append RS_SPLIT_SHRUNK to RSML (with identifier of split-off Range)
  # Update METADATA for old range 
  # Create METADATA entry for new range with '!StartRow' and 'Files' columns 
  # Quiesce updates
  # Close transfer log
  # Shrink access groups
  # Un-quiesce updates
  # Notify Master of split
  # Upon receiving Error::OK response from Master write RS_SPLIT_DONE entry in RSML

=== Master ===
  
  # Master::report_split() called by originating !RangeServer
  # Selects a !RangeServer for the newly split off range
  # Writes M_LOAD_RANGE_START (with location of receiving !RangeServer) entry to MML
  # Calls load_range(<split-log>) on receiving !RangeServer
  # Update METADATA 'Location' column for the new range
  # Issue drop_range() for the new range to the originating !RangeServer
  # Write M_LOAD_RANGE_DONE entry to MML

=== Receiving !RangeServer ===

  # Create Range directory in DFS
  # Link transfer log into primary log
  # Append RS_RANGE_LOADED in RSML
  # Replay transfer log
  # Add Range object to main map
  # Respond OK to Master

-----

== Create Table ==

  # Selects a !RangeServer for the initial range
  # Writes M_LOAD_RANGE_START (with location of receiving !RangeServer) to MML
  # Update METADATA 'Location' column for range
  # Calls load_range() on receiving !RangeServer
  # Upon receipt of Error::OK, write M_LOAD_RANGE_DONE entry to MML

-----

== !RangeServer Restart (Fast Recovery) ==

When a !RangeServer comes up, it will acquire a lock on a well-known file in Hyperspace with the following name format:

`/hypertable/servers/<ip-address>_<port>`

It holds on to this lock the entire time it is up.  If it is unable to acquire the lock it will go into a retry loop.  Once it successfully acquires the lock, it will then check to see if there is an RSML for this machine/port combo in the DFS.  This log will be found in the following well-known location:

`/hypertable/servers/<ip-address>_<port>/log/meta`

If the RSML does not exist, the !RangeServer will just come up and wait for the Master to assign it ranges.  Otherwise, if the RSML does exist, it will carry out the following recovery procedure:

  # Scan the RSML to figure out the state of all of the Ranges that the prior !RangeServer had loaded
  # Load all of the Ranges
  # Replay the primary commit log
  # For Ranges in the RS_SPLIT_START state, replay the transfer log and initiate a split, appending to the existing transfer log.
  # For Ranges in the RS_SPLIT_SHRUNK state, initiate a report_split_to_master() task

-----

== !RangeServer Recovery - Master ==

When the Master discovers that a !RangeServer has died (via Hyperspace notification), it waits for some grace period and then attempts to acquire a lock on a well-known file in Hyperspace with the following name format:

`/hypertable/servers/<ip-address>_<port>`

where the ip-address and port correspond to the !RangeServer that died.  If it is unable to acquire the lock, then it assumes that a !RangeServer has been restarted on the same IP address and port and is handling recovery.  If it is able to acquire the lock, then it carries out the following sequence of steps:
  # Write a M_RECOVERY_START entry in the MML that contains the dead !RangeServer)
  # Rename the dead range server commit log directory in DFS to '.../commit-recover'
  # Read the RSML of the deceased !RangeServer to reconstruct the state of all the Ranges it had loaded
  # Find new locations (!RangeServers) for all the ranges.
  # Write new locations in the METADATA.
  # For ranges that were in the RS_RANGE_LOADED state, write M_LOAD_RANGE_START for the range and its target range server in MML and issue a corresponding load_range()
  # For ranges that were in the RS_SPLIT_START state, write M_LOAD_RANGE_START for the range and its target range server in MML and issues a load_range(), but set a flag indicating a split was in progress and pass along the location of the transfer log.
  # For ranges that were in the RS_SPLIT_SHRUNK state, finish the split as follows
    # For the original range that was shrunk, select a !RangeServer and write M_LOAD_RANGE_START for the range and its new range server in MML and issue a load_range()
    # For the newly split-off range, got to step #2 of Range Split -> Master above
  # For each successful load_range(), write M_LOAD_RANGE_DONE for the range in MML
  # When all load_range() succeeded, delete the commit-recovery directory for the dead range server and write M_RECOVERY_DONE for the dead range server in MML

-----

== Master Startup ==

  # Read MML and reconstruct state
  # For all ranges that were in M_LOAD_RANGE_START or M_RECOVERY_START but not M_LOAD_RANGE_DONE mode, follow the above 'Range server recovery - Master' from step 4.
  # For all ranges that were in M_MOVE_RANGE_START mode, follow the below 'Range Move - Master' from step 3.

-----

== Range Move ==

=== Master ===
  # Select source range and destination range server
  # Write M_MOVE_RANGE_START with the range and its source and destination servers in MML
  # Issue prepare_range_move() on the source range server
  # Write M_LOAD_RANGE_START with the range and its destination in MML and issue a corresponding load_range() with transfer log location
  # Update METADATA 'Location' for the range
  # Write M_LOAD_RANGE_DONE with the range in MML
  # Issue drop_range() on the source range server
  # Write M_MOVE_RANGE_DONE with the range in MML

=== Range Server ===
  # prepare_range_move() called by Master
  # Create a transfer log and append RS_MOVE_START with the log location in RSML
  # Do major compaction for the range
  # Quiesce updates to the range
  # Close transfer log
  # Append RS_MOVE_PREPARED for the range to RSML
  
-----

== Implementation TODO Tasks ==

  * Sweep through code and change location from `<ip-address>_<port>_<timestamp>` to just `<ip-address>_<port>`
  * Implement !MetaLog
  * Change code so that Ranges can be created in the RS_SPLIT_START state which involves installing a !SplitLog and initiating a split
  * Change code so that Ranges can be created in the RS_SPLIT_SHRUNK state, which involves scheduling a "notify master" task.
  * Modify !MaintainenceQueue to allow for certain failed tasks to get rescheduled (e.g. "notify master")
  * Implement "Fast Recovery" in !RangeServer.  This involves obtaining the lock on the !RangeServer's lock in Hyperpspace, reading the RSML and re-building the Range objects in  their various states.
  * Change !RangeServer split logic as described above in Range Split -> Originating !RangeServer above
  * Allow load_range() on already loaded ranges.  If the Master dies in the middle of recovery, when the next Master takes over it may ask a !RangeServer to load a range that it already successfully loaded.  I should return an error like RANGE_ALREADY_LOADED.
  * ...