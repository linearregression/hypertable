#summary Design of range meta-operation transactions
#labels Phase-Design

== Introduction ==

Ranges are assigned and re-assigned to !RangeServers by the following operations:

  * CREATE TABLE
  * Range split
  * Range migration

To ensure that each Range get assigned to a !RangeServer and that a Range doesn't accidentally get assigned to multiple !RangeServers, even in the face of failures, we've decided to implement a specialized form of range meta-operation transactions.  This document describes the design of this mechanism.

To support these range meta-operation "transactions", we've introduced two new commit logs:

  # RSML - !RangeServer Meta Log
  # MML - Master Meta Log

These logs are where all Range meta operations get recorded for the !RangeServers and Master, respectively.

-----

== Range Split ==

=== Originating !RangeServer ===

  * Decide to split range
  * Create a split log and append SPLIT_START entry to RSML (include split log location)
  * Atomically obtain split timestamp and install split log
  * Do major compaction
  * Quiesce updates
  * Close split log
  * Update METADATA for old range 
  * Append SPLIT_SHRUNK to RSML (with identifier of split-off Range)
  * Shrink cell cache
  * Shrink view onto cell stores
  * Un-quiesce updates
  * Notify Master of split
  * Upon receiving Error::OK response from Master write SPLIT_DONE entry in RSML

=== Master ===

  * Master::report_split() called by originating !RangeServer
  * Selects a !RangeServer for the newly split off range
  * Writes LOAD_START (with location of receiving !RangeServer) to MML
  * Update METADATA 'Location' column for range
  * Calls load_range() on receiving !RangeServer
  * Upon receipt of Error::OK, write LOAD_FINISH

=== Receiving !RangeServer ===

  * Create Range directory in DFS
  * Link split log into primary log
  * Append RANGE_LOADED in RSML
  * Replay split log
  * Add Range object to main map
  * Respond OK to Master

-----

== Range Move ==

-----

== Create Table ==

-----

== !RangeServer Restart (Fast Recovery) ==

When a !RangeServer comes up, it will acquire a lock on a well-known file in Hyperspace with the following name format:

`/hypertable/servers/<ip-address>_<port>`

It holds on to this lock the entire time it is up.  If it is unable to acquire the lock it will go into a retry loop.  Once it successfully acquires the lock, it will then check to see if there is an RSML for this machine/port combo in the DFS.  This log will be found in the following well-known location:

`/hypertable/servers/<ip-address>_<port>/commit/meta`

If the RSML does not exist, the !RangeServer will just come up and wait for the Master to assign it ranges.  Otherwise, if the RSML does exist, it will carry out the following recovery procedure:

  * Scan the RSML to figure out the state of all of the Ranges that the prior !RangeServer had loaded
  * Load all of the Ranges
  * Replay the primary commit log
  * For Ranges in the SPLIT_START state, replay the split log and initiate a split, appending to the existing split log.
  * For Ranges in the SPLIT_SHRUNK state, initiate a report_split_to_master() task

-----

== !RangeServer Master Recovery ==

== Implementation Tasks ==