#summary Design of range meta-operation transactions
#labels Phase-Design

== Introduction ==

Ranges are assigned and re-assigned to !RangeServers by the following operations:

  * CREATE TABLE
  * Range split
  * Range migration

To ensure that each Range get assigned to a !RangeServer and that a Range doesn't accidentally get assigned to multiple !RangeServers, even in the face of failures, we've decided to implement a specialized form of range meta-operation transactions.  This document describes the design of this mechanism.

To support these range meta-operation "transactions", we've introduced two new commit logs:

  # RSML - !RangeServer Meta Log
  # MML - Master Meta Log

These logs are where all Range meta operations get recorded for the !RangeServers and Master, respectively.

-----

== Range Split ==

=== Originating !RangeServer ===

  # Decide to split range
  # Create a split log and append SPLIT_START entry to RSML (include split log location)
  # Atomically obtain split timestamp and install split log
  # Do major compaction
  # Quiesce updates
  # Close split log
  # Update METADATA for old range 
  # Append SPLIT_SHRUNK to RSML (with identifier of split-off Range)
  # Shrink cell cache
  # Shrink view onto cell stores
  # Un-quiesce updates
  # Notify Master of split
  # Upon receiving Error::OK response from Master write SPLIT_DONE entry in RSML

=== Master ===

  # Master::report_split() called by originating !RangeServer
  # Selects a !RangeServer for the newly split off range
  # Writes LOAD_START (with location of receiving !RangeServer) entry to MML
  # Update METADATA 'Location' column for range
  # Calls load_range(<split-log>) on receiving !RangeServer
  # Upon receipt of Error::OK, write LOAD_FINISH entry to MML

=== Receiving !RangeServer ===

  # Create Range directory in DFS
  # Link split log into primary log
  # Append RANGE_LOADED in RSML
  # Replay split log
  # Add Range object to main map
  # Respond OK to Master

-----

== Create Table ==

  # Selects a !RangeServer for the initial range
  # Writes LOAD_START (with location of receiving !RangeServer) to MML
  # Update METADATA 'Location' column for range
  # Calls load_range() on receiving !RangeServer
  # Upon receipt of Error::OK, write LOAD_FINISH entry to MML

-----

== !RangeServer Restart (Fast Recovery) ==

When a !RangeServer comes up, it will acquire a lock on a well-known file in Hyperspace with the following name format:

`/hypertable/servers/<ip-address>_<port>`

It holds on to this lock the entire time it is up.  If it is unable to acquire the lock it will go into a retry loop.  Once it successfully acquires the lock, it will then check to see if there is an RSML for this machine/port combo in the DFS.  This log will be found in the following well-known location:

`/hypertable/servers/<ip-address>_<port>/commit/meta`

If the RSML does not exist, the !RangeServer will just come up and wait for the Master to assign it ranges.  Otherwise, if the RSML does exist, it will carry out the following recovery procedure:

  # Scan the RSML to figure out the state of all of the Ranges that the prior !RangeServer had loaded
  # Load all of the Ranges
  # Replay the primary commit log
  # For Ranges in the SPLIT_START state, replay the split log and initiate a split, appending to the existing split log.
  # For Ranges in the SPLIT_SHRUNK state, initiate a report_split_to_master() task

-----

== !RangeServer Recovery - Master ==

When the Master discovers that a !RangeServer has died (via Hyperspace notification), it waits for some grace period and then attempts to acquire a lock on a well-known file in Hyperspace with the following name format:

`/hypertable/servers/<ip-address>_<port>`

where the ip-address and port correspond to the !RangeServer that died.  If it is unable to acquire the lock, then it assumes that a !RangeServer has been restarted on the same IP address and port and is handling recovery.  If it is able to acquire the lock, then it carries out the following sequence of steps:

  # Reads the RSML of the deceased !RangeServer to reconstruct the state of all the Ranges it had loaded
  # Finds new locations (!RangeServers) for all the ranges
  # Writes a RECOVERY_START entry in the MML that contains the list of ranges and their state at the time of !RangeServer death (also include location of new !RangeServer)
  # For ranges that were in the RANGE_LOADED state, issues a load_range() on the new !RangeServer
  # For ranges that were in the SPLIT_START state, issues a load_range(), but sets a flag indicating a split was in progress and pass along the location of the split log.
  # For ranges that were in the SPLIT_SHRUNK state, finish the split as follows
    # For the original range that was shrunk, select a !RangeServer and issue a load_range() for the range
    # For the newly split-off range, got to step #2 of Range Split -> Master above.
  # As each load_range() completes successfully, wrote a RECOVERY_COMPLETE entry into the MML including the Range identifier

-----

== Master Startup ==

  # Read MML and reconstruct state
  # For all ranges that were in LOAD_START or RECOVERY_START mode, by writing the 'Location' field of METADATA and then calling load_range()

-----

== Range Move ==

TBD

-----

== Implementation TODO Tasks ==

  * Sweep through code and change location from `<ip-address>_<port>_<timestamp>` to just `<ip-address>_<port>`
  * Implement !MetaLog
  * Change code so that Ranges can be created in the SPLIT_START state which involves installing a !SplitLog and initiating a split
  * Change code so that Ranges can be created in the SPLIT_SHRUNK state, which involves scheduling a "notify master" task.
  * Modify !MaintainenceQueue to allow for certain failed tasks to get rescheduled (e.g. "notify master")
  * Implement "Fast Recovery" in !RangeServer.  This involves obtaining the lock on the !RangeServer's lock in Hyperpspace, reading the RSML and re-building the Range objects in  their various states.
  * Change !RangeServer split logic as described above in Range Split -> Originating !RangeServer above
  * Allow load_range() on already loaded ranges.  If the Master dies in the middle of recovery, when the next Master takes over it may ask a !RangeServer to load a range that it already successfully loaded.  I should return an error like RANGE_ALREADY_LOADED.
  * ...