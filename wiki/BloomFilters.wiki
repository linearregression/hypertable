#summary Design Overview for BloomFilters.

= Summary =

BloomFilters can be used to avoid going to disk for read queries relating to specified row/column pairs. This document describes a design for the same in Hypertable.

= Intro to Bloom Filters =

!BloomFilter is a space efficient probabilistic data structure used to test whether an element is a member of a set. False positives are possible, but false negatives are not. For more, please see http://en.wikipedia.org/wiki/Bloom_filter.

= Use in Hypertable =

Read operations on hypertable have to read from all the !CellStores as well as the !CellCache to compute the pertinent cells, and answer the query. The !CellCache accesses are all in-memory, but the !CellStore accesses can result in many disk seeks, if the blocks containing the relevant keys are not in memory. When the keys being queried for are known apriori, maintaining a bloom filter in the !CellStore can reduce the number of disk accesses significantly. We use the !BloomFilter to reduce disk lookups for rows and columns that have no values in the !CellStore.

The !BloomFilter in a !CellStore will have bits set for every key and key:column_family:column_name that have values in the !CellStore. At query time, a !CellStore is ignored if !CellStore::may_contain(key) or !CellStore::may_contain(key,column) returns false, thus saving a disk access to figure out non-existence.

= Implementation =

1. Augment the Hypertable::CellStore interface by adding the virtual functions:
    - may_contain(const char *key)
    - may_contain(const char *key, uint8_t column_family_code, const char *column_qualifier)

2. Add a BloomFilter instance to CellStore
    - serialization for CellStore puts the serialized BloomFilter after the fixed index and variable index are written
    - CellStoreTrailer contains filter_offset, which enables us to locate the BloomFilter data
    - add(key, value, timestamp) updates the bloomfilter by inserting in
      - the row key extracted from "key"
      - row_key '\0' column_family_code column_qualifier '\0'
    - may_contain(const char *rowkey)
      - looks up key in the BloomFilter and returns true / false
    - may_contain(rowkey, column_family, column_qualifier) 
      - constructs the byte sequence to look up, looks up bloom filter, and returns true / false

3. AccessGroup::CreateScanner (scan_context)
    - check to see from scan_context if query is for a set of specified keys
    - if false, do what is currently being done
    - else, before creating and adding a scanner for a cell store, check the cell store to see if may_contain(key) and may_contain(key,column_family, column_qualifier) return true for atleast one of the keys. only add if satisfied.

4. 