#summary Overview of Hypertable Architecture

== Contents ==

  * Introduction
  * Data Model
  * Physical Data Layout
  * System Components
  * Client Library
  * Source Code

== Introduction ==

This document gives an architectural overview of Hypertable.  Hypertable is designed to run on top of a "third party" distributed filesystem, such as Hadoop DFS.  However, the system can also be run on top of a normal local filesystem.  We recommend that you start with the local filesystem to get up and running and to play around with the system.  

The best way to get started hands-on using hypertable is to first [http://code.google.com/p/hypertable/wiki/SourceCode?tm=4 download the source code], build it, and get the regression tests to pass.  Once the regression tests are all passing, you can then start the servers runing on top of the local filesystem with the following command (assuming the installation directory is ~/hypertable/0.9.0.5):

{{{
$ ~/hypertable/0.9.0.5/bin/start-all-servers.sh local
Successfully started DFSBroker (local)
Successfully started Hyperspace
Successfully started Hypertable.Master
Successfully started Hypertable.RangeServer
$
}}}

You can create tables, load data, and issue queries with the Hypertable command interpreter "hypertable":

{{{
$ ~/hypertable/0.9.0.5/bin/hypertable 

Welcome to the hypertable command interpreter.
For information about Hypertable, visit http://www.hypertable.org/

Type 'help' for a list of commands, or 'help shell' for a
list of shell meta commands.

hypertable>
}}}

To get a list of all the commands available, type 'help':

{{{
hypertable> help

CREATE TABLE ....... Creates a table
DELETE ............. Deletes all or part of a row from a table
DESCRIBE TABLE ..... Displays a table's schema
DROP TABLE ......... Removes a table
INSERT ............. Inserts data into a table
LOAD DATA INFILE ... Loads data from a tab delimited input file into a table
SELECT ............. Selects (and display) cells from a table
SHOW CREATE TABLE .. Displays CREATE TABLE command used to create table
SHOW TABLES ........ Displays the list of tables

Statements must be terminated with ';' to execute.  For more information on
a specific statement, type 'help <statement>', where <statement> is one from
the preceeding list.

hypertable> 
}}}


== Data Model ==

The Hypertable data model consists of a multi-dimensional table of information that can be queried using a single primary key.  The first dimension of the table is the row key.  The row key is the primary key and defines the order in which the table data is physically stored.  The second dimension is the column family.  This dimension is somewhat analogous to a traditional database column.  The third dimension is the column qualifier.  Within each column family, there can be a theoretically infinite number of qualified instances.  For example if we were building a URL tagging service, we might define column families content, url, and tag.  Within the "tag" column family there could be an infinite number of qualified instances, such as `tag:science`, `tag:theater`, `tag:good`, etc.  The fourth and final dimension is the time dimension.  This dimension consists of a timestamp that is usually auto assigned by the system and represents the insertion time of the cell in nanoseconds since the epoch.  Conceptually, a table in Hypertable can be thought of as a three dimensional Excel spreadsheet with timestamped versions of each cell.

The following diagram graphically depicts a crawl database table called crawldb.  The row key is the URL of a page to be crawled and the column families include:  title, content, and anchor.  The "anchor" column family illustrates the use of column qualifiers.

http://www.hypertable.org/images/DataModel.jpg

Under the hood, this multi-dimensional table of information is represented as a flat sorted list of key/value pairs.  The key is essentially the concatenation of the four dimension keys (row, column family, column qualifier, and timestamp).  The following diagram depicts the flattened key.  One thing to note is that the timestamp is stored ones compliment big-endian so that the most recent cell sorts ahead of older versions of a cell.

http://www.hypertable.org/images/HypertableKeyDiagram.jpg

So the above crawldb table would have a flattened representation that looks something like the following:

http://www.hypertable.org/images/DataModelFlattened.jpg

== Physical Data Layout ==

All table data is stored in the underlying distributed filesystem.

== System Components ==

The following diagram illustrates all of the processes in the system and how they relate to one another.

http://www.hypertable.org/images/SystemOverview.jpg

*Hyperspace* - This is our system's equivalent of [http://labs.google.com/papers/chubby.html Chubby].  Hyperspace (or Chubby) is a service that provides a filesystem for storing small amounts of metadata.  It also acts as a lock manager in that either exclusive or shared lock and be acquired on any of the files or directories.  Currently it is implemented as just a single server, but will be made distributed and highly available at some point in the near future.  Google refers to Chubby as, "the root of all distributed data structures" which is a good way to think of this system.

*Range Server* - Tables are broken into a set of contiguous row ranges, each of which is managed by a range server.  Initially each table consists of a single range that spans the entire row key space.  As the table fills with data, the range will eventually exceed a size threshold (default is 200MB) and will split into two ranges using the middle row key as a split point.  One of the ranges will stay on the same range server that held the original range and the other will get reassigned to another range server by the Master.  This splitting process continues for all of the ranges as they continue to grow.

Each range server handles all of the reading and writing of table data for the ranges that it is responsible for.  Range servers cache updates in memory (after writing them to a Commit Log) in what's called a !CellCache.  Periodically the !CellCache will get flushed to disk (e.g. the DFS) in a specially formatted file called a !CellStore.  To scan over the data in a range, the range server must do a heap merge of the !CellCache and all of the !CellStores for the range.  The following diagram illustrates this process.

http://www.hypertable.org/images/MergeScan.jpg

*Master* - 

*DFS Broker* - 

== Client Library ==

== Source Code ==