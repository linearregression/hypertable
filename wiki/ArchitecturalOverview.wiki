#summary Overview of Hypertable Architecture

== Contents ==

  * Introduction
  * Data Model
  * System Components
  * Client Library
  * Source Code

== Introduction ==

This document gives an architectural overview of Hypertable.  The best way to get started hands-on using hypertable is to first [http://code.google.com/p/hypertable/wiki/SourceCode?tm=4 download the source code], build it, and get the regression tests to pass.  Once the regression tests are all passing, you can then start the servers runing on top of the local filesystem with the following command (assuming the installation directory is ~/hypertable/0.9.0.5):

{{{
$ ~/hypertable/0.9.0.5/bin/start-all-servers.sh local
Successfully started DFSBroker (local)
Successfully started Hyperspace
Successfully started Hypertable.Master
Successfully started Hypertable.RangeServer
$
}}}

You can create tables, load data, and issue queries with the Hypertable command interpreter "hypertable":

{{{
$ ~/hypertable/0.9.0.5/bin/hypertable 

Welcome to the hypertable command interpreter.
For information about Hypertable, visit http://www.hypertable.org/

Type 'help' for a list of commands, or 'help shell' for a
list of shell meta commands.

hypertable>
}}}

To get a list of all the commands available, type 'help':

{{{
hypertable> help

CREATE TABLE ....... Creates a table
DELETE ............. Deletes all or part of a row from a table
DESCRIBE TABLE ..... Displays a table's schema
DROP TABLE ......... Removes a table
INSERT ............. Inserts data into a table
LOAD DATA INFILE ... Loads data from a tab delimited input file into a table
SELECT ............. Selects (and display) cells from a table
SHOW CREATE TABLE .. Displays CREATE TABLE command used to create table
SHOW TABLES ........ Displays the list of tables

Statements must be terminated with ';' to execute.  For more information on
a specific statement, type 'help <statement>', where <statement> is one from
the preceeding list.

hypertable> 
}}}


== Data Model ==

The Hypertable data model consists of a multi-dimensional table of information that can be queried using a single primary key.  The first dimension of the table is the row key.  The row key is the primary key and defines the order in which the table data is physically stored.  The second dimension is the column family.  This dimension is somewhat analogous to a traditional database column.  The third dimension is the column qualifier.  Within each column family, there can be a theoretically infinite number of qualified instances.  For example if we were building a URL tagging service, we might define column families content, url, and tag.  Within the "tag" column family there could be an infinite number of qualified instances, such as `tag:science`, `tag:theater`, `tag:good`, etc.  The fourth and final dimension is the time dimension.  This dimension consists of a timestamp that is usually auto assigned by the system and represents the insertion time of the cell in nanoseconds since the epoch.  Conceptually, a table in Hypertable can be thought of as a three dimensional Excel spreadsheet with timestamped versions of each cell.

The following diagram graphically depicts a crawl database table called crawldb.  The row key is the URL of a page to be crawled and the column families include:  title, content, and anchor.  The "anchor" column family illustrates the use of column qualifiers.

http://www.hypertable.org/images/DataModel.jpg

Under the hood, this multi-dimensional table of information is represented as a flat sorted list of key/value pairs.  The key is essentially the concatenation of the four dimension keys (row, column family, column qualifier, and timestamp).  The following diagram depicts the flattened key.  One thing to note is that the timestamp is stored ones compliment big-endian so that the most recent cell sorts ahead of older versions of a cell.

http://www.hypertable.org/images/HypertableKeyDiagram.jpg

So the above crawldb table would have a flattened representation that looks something like the following:

http://www.hypertable.org/images/DataModelFlattened.jpg


== System Components ==

The following diagram illustrates all of the processes in the system and how they relate to one another.

http://www.hypertable.org/images/SystemOverview.jpg

*Hyperspace* - This is our system's equivalent of [http://labs.google.com/papers/chubby.html Chubby].  Hyperspace (or Chubby) is a service that provides a filesystem for storing small amounts of metadata.  It also acts as a lock manager in that either exclusive or shared lock and be acquired on any of the files or directories.  Currently it is implemented as just a single server, but will be made distributed and highly available at some point in the near future.  Google refers to Chubby as, "the root of all distributed data structures" which is a good way to think of this system.

*Range Server* - These processes are responsible for managing ranges of table data that get assigned to them by the Master.  They handle all of the reading and writing of table data for the ranges that they are responsible for.  Range servers cache updates in memory (after writing them to a Commit Log) in what's called a CellCache.  Periodically the CellCache will get flushed to disk (e.g. the DFS) in a specially formatted file called a CellStore.  To scan over the data in a range, the Range Server must

Subsequent requests to scan over the data



*Master* - 

*DFS Broker* - 

== Client Library ==

== Source Code ==