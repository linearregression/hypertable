#summary Design overview for Range Server recovery

== Introduction ==

When a Range Server goes down, all of the ranges that it manages need to get re-assigned to other range servers.  This is performed by the Master.  This document describes the process.

== Master Recovery Procedure ==
  * Master gets notified of !RangeServer failure via Hyperspace
  _What happens if this notification is lost due to Master failover happening simultaneously?_
  * Master writes a STARTING_RANGE_SERVER_RECOVERY entry into its log
  
  * Master re-assigns all of the tablets previously owned
  
  * For each tablet server that is receiving a recovered range:
    * Master issues load_range() with the recovery or "phantom" flag set to true
  
  * Master replays the commit log as by reading each log entry and reading the commit timestamp for the entry and sending that timestamp along with the updates to each range server involved in the replay.
  _Maybe tee commits into local commit logs, one for each range, for ease of recovery should one of the !RangServers die in the middle of recovery._
  * This happens for all of the log entries
  
  * After log has been completely replayed, the Master issues a go_live() request to each of the range servers that received a recovered log.
  
  * Master writes a FINISHED_RANGE_SERVER_RECOVERY entry into its log

== Range Server Recovery Procedure ==

  * When normal updates are received by a range server, they get persisted into a commit log.  This group of updates gets written as a single entry that begins with a fixed header.  The header includes the real timestamp (i.e. real time sampled by the server prior to the commit) of the commit.

  * When an Access Group is compacted, the real time of the compaction is written into the !CellStore trailer.  The most recent timestamp from all of the !CellStore trailers is taken to be the _last_compaction_time_ for the Access Group.

  * When recovering a range, the Master will issue a load_range() request to the range server with the PHANTOM bit set in the flags argument.  When this happens, the !RangeServer will create the Range object which will load all of the !CellStores and determine the _last_compaction_time_ for each Access Group.  The !RangeServer will then put the Range object into a special "phantom" map and will also create a single "phantom" commit log for all of the ranges that get loaded with the PHANTOM bit set.

  * When the Master replays the commit log from the failed !RangeServer, it will read the real timestamp of the commit log entry and send it, along with the updates, to each !RangeServer receiving a recovered Range.  It does this by invoking the `RangeServer::phantom_update()` method

  * For each call to `phantom_update()`, the !RangeServer will call a special version of Range::add() that will ignore any updates to an Access Group that have a timestamp that is less than the _last_compaction_time_ for the Access Group.

  * After the Master has replayed the entire commit log, it will issue a go_live() request to all of the !RangeServers.  Each !RangeServer will atomically move all of its "phantom" ranges into the the main Range map and will link the "phantom" commit log into the main commit log.



