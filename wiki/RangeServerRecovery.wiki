#summary Design overview for Range Server recovery

== Introduction ==

When a Range Server goes down, all of the ranges that it manages need to get re-assigned to other range servers.  This is performed by the Master.  This document describes the process.

== Master Recovery Procedure ==
  * Master gets notified of !RangeServer failure via Hyperspace
  _What happens if this notification is lost due to Master failover happening simultaneously?_
  * Master writes a STARTING_RANGE_SERVER_RECOVERY entry into its log
  
  * Master re-assigns all of the Ranges owned by the failed !RangeServer to new !RangeServers.  It does this by invoking the `RangeServer::load_range()` method with the PHANTOM bit set in the flags argument, for each Range being recovered.
    
  * Master replays the commit log by doing the following for each log entry:
    * Reads the _timestamp_ and _table name_ from the header of the log entry
    * If the table is not open, then it is opened and a !TableMutator is created in "replay mode".  This "replay mode" tells the !TableMutator to consult the !PhantomLocation column of the METADATA table when looking for ranges.
    * The updates are replayed by invoking a the `TableMutator::replay` method with the block of updates and the timestamp retrieved from the header.  This method will write these replayed commits into a scatter buffer and periodically flush these commits to the !RangeServers with a call `to phantom_update()`.
    _Maybe tee commits into local commit logs, one for each range, for ease of recovery should one of the !RangServers die in the middle of recovery._

  * After log has been completely replayed, the Master issues a `go_live()` request to each of the range servers that received a recovered log.
  
  * Master writes a FINISHED_RANGE_SERVER_RECOVERY entry into its log

== Range Server Recovery Procedure ==

  * When normal updates are received by a range server, they get persisted into a commit log.  This group of updates gets written as a single entry that begins with a fixed header.  The header includes the real timestamp (i.e. real time sampled by the server prior to the commit) of the commit.

  * When an Access Group is compacted, the real time of the compaction is written into the !CellStore trailer.  The most recent timestamp from all of the !CellStore trailers is taken to be the _last_compaction_time_ for the Access Group.

  * When recovering a range, the Master will issue a load_range() request to the range server with the PHANTOM bit set in the flags argument.  When this happens, the !RangeServer will create the Range object which will load all of the !CellStores and determine the _last_compaction_time_ for each Access Group.  The !RangeServer will then put the Range object into a special "phantom" map and will also create a single "phantom" commit log for all of the ranges that get loaded with the PHANTOM bit set.

  * When the Master replays the commit log from the failed !RangeServer, it will read the real timestamp of the commit log entry and send it, along with the updates, to each !RangeServer receiving a recovered Range.  It does this by invoking the `RangeServer::phantom_update()` method

  * For each call to `phantom_update()`, the !RangeServer will commit the updates to the "phantom" commit log and then call a special version of `Range::add()` that will ignore any updates to an Access Group that have a timestamp that is less than the _last_compaction_time_ for the Access Group.

  * After the Master has replayed the entire commit log, it will invoke the `RangeServer::go_live()` method of all the Range Servers involved in the recovery.  Each !RangeServer will atomically move all of its "phantom" ranges into the the main Range map and will link the "phantom" commit log into the main commit log.